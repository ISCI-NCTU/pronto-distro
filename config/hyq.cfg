coordinate_frames {
  root_frame = "local";
  
  # this is the pelvis/trunk/base link
  body {
    relative_to = "local";
    history = 2000;
    max_frequency = 1000;
    pose_update_channel = "POSE_BODY";
    #update_channel = "HEAD_TO_BODY";  
    initial_transform{
      translation = [ 0, 0, 0 ];
      rpy = [0, 0, 0];
    }
  }

  imu {
    relative_to = "body";
    history = 2000;
    #update_channel = "BODY_TO_IMU";  
    initial_transform{
      translation = [ 0.290, 0.000, 0.0999214 ];
      rpy = [0,0,0];
      #rpy = [0,-180,0];
    }
  }  


  # 4m Hokuyo URG (old style lidar)
  SCAN {
    relative_to = "body";
    history = 2000;
    #update_channel = "BODY_TO_SCAN";
    initial_transform{
      translation = [ 0.475, 0.000, -0.143 ];
      rpy = [180, 0.000, 0.000];
    }
  }

  
  # An alternative body frame, for comparison with POSE_BODY
 # when developing state estimation
  body_alt {
    # this cannot change - its rigid
    relative_to = "local";
    history = 2000;
    #update_channel = "BODY_TO_SCAN";
    initial_transform{
      translation = [ 0.475, 0.000, -0.143 ];
      rpy = [180, -0.000, 0.000];
    }
  }


  # HDL-32E mid-sized Velodyne
  VELODYNE {
    relative_to = "body";
    history = 2000;
    #update_channel = "BODY_TO_VELODYNE";
    initial_transform{
      translation = [ 0.39, 0, 0.269 ];
      # original
      #rpy = [0.0, 0.0, 180.000];
      # mfallon, manual attempt to correct for pitch and roll
      rpy = [-0.25, -1.4500, 180.000];
    }
  }
  
  # Pose as published by Vicon
  # for a short time was VICON_BODY
  body_vicon {
    relative_to = "local";
    history = 2000;
    update_channel= "VICON_TO_LOCAL";
    initial_transform{
      translation=[  0 , 0.0 , 0.0 ];
      rpy = [0.0 , 0.0 , 0.0 ];
    }
  } 
  
  # Transform between marker frame and body
  # (eventually) known fixed transform
  #body_vicon {
  #  relative_to = "vicon";
  #  history = 2000;
  #  update_channel= "VICON_";
  #  initial_transform{
  #    # optimized for new vsk files by A. Valenzuela 21 Mar 2014
  #    translation = [0, 0, 0];
  #    quat = [1, 0, 0, 0];
  #  }
  #} 
  
  pose_vicon {
    relative_to = "local";
    history = 2000;
    max_frequency = 100;
    pose_update_channel= "POSE_VICON";
    initial_transform{
      translation=[  0 , 0.0 , 0.0 ];
      rpy = [0.0 , 0.0 , 0.0 ];
    }
  }


  body_scanmatcher {
    # this cannot change - its rigid
    relative_to = "local";
    history = 2000;
    max_frequency = 100;
    pose_update_channel= "POSE_BODY_SCANMATCHER";
    initial_transform{
      translation=[  0 , 0.0 , 0.0 ];
      rpy = [0.0 , 0.0 , 0.0 ];
    }
  }


}


planar_lidars {
  SCAN {
    viewer_color = [ 1.0, 0.0, 0.0 ]; # red
    max_range = 29.0;
    min_range = 0.1;
    frequency = 40;
    laser_type = "HOKUYO_URG";
    coord_frame = "SCAN";
    lcm_channel = "SCAN";
    surround_region = [0, 1000000];
    up_region = [-1,-1];
    down_region = [-1, -1];
    max_range_free_dist = 29.0;
  }

  # required for mav estimator gpf (but not actually used for gpf)
  laser {
    viewer_color = [ 1.0, 0.0, 0.0 ]; # red
   max_range = 29.0;
    min_range = 0.1;
    frequency = 40;
    laser_type = "HOKUYO_UTM";
    coord_frame = "VELODYNE";
    lcm_channel = "VELODYNE";
    surround_region = [0, 1000000];        
    up_region = [-1,-1];
    down_region = [-1, -1];
    max_range_free_dist = 29.0;
  }

}


cameras {

}


state_estimator {
  # when processing from log set
  # false: republish_sensors, republish_cameras, publish_filter_state, gpf_vis, publish_diagnostics
  # true:  enable_at_launch (GPF), republish_incoming_poses (POSE_VICON & BDI)

  # when processing gpf:
  # init from vicon and ins but not pose_meas
  # use VICON_BODY when doing GPF from file
  # gpf_vis = false
  # additionally when running gpf out of process:
  # publish_filter_state=true
  # enable_at_launch = false

  # when running on robot use pose_meas to start from BDI Pose


  pose_channel = "POSE_BODY"; # was POSE_BODY_ALT
  filter_state_channel = "STATE_ESTIMATOR_STATE";
  # the frame at which to draw convariance information in viewer
  pose_render_frame = "body"; # was body_alt

  publish_filter_state = true; #publish alongside pose
  publish_pose = true;
  republish_sensors = true; # if using a log, otherwise make s

  # ins,vicon, pose_meas
  #init_sensors = ["ins","vicon"];
  init_sensors = ["ins","vicon"];
  # laser_gpf, ins, rgbd_gpf, fovis, legodo , vicon, pose_meas, laser_gpf_out_of_process
  #active_sensors = ["ins", "scan_matcher", "laser_gpf_out_of_process"];
  #active_sensors = ["ins", "laser_gpf_out_of_process"];
  active_sensors = ["ins","hyq_kse"];

  # was this: 1000000 (1sec) for mav
  utime_history_span =1000000;

  #initial state estimate (relavent states overridden by init sensors)
  sigma0 {
          vb = 0.15; #m/s
          chi_xy = 3.0; #degrees?
          chi_z = 3.0; #degrees?
          Delta_xy = 0.05;#.5; #m
          Delta_z = 0.05;#1;    #m

          gyro_bias = 0; #deg/seg
          accel_bias = 0; #m/s^2 # 0.1 worked during tuning
  }

  x0 {
    velocity = [0,0,0];
    angular_velocity = [0,0,0];
    position = [0, 0, 0.0];
    rpy = [0, 0, 0];
  }

  init_message {
    channel = "MAV_STATE_EST_INITIALIZER";
  }

  viewer {
    channel = "MAV_STATE_EST_VIEWER_MEASUREMENT";
    utime_offset = 0; #units 1e-6 seconds
    downsample_factor = 1; # process 1 out of every this many
    roll_forward_on_receive = true;
    publish_head_on_message = true;
  }

  ins {
    channel ="MICROSTRAIN_INS";
    utime_offset = 0; #units 1e-6 seconds
    downsample_factor = 1; # process 1 out of every this many. for 333Hz use 1. for 1kHz use 3
    roll_forward_on_receive = true;
    publish_head_on_message = true;

    # microstrain: 0.5 | 0.2 | 0 | 0
    # i always used 0.5 | 0.2 | 0 | 0
    q_gyro = 0.5; #deg/sec
    q_accel = 0.2; #m/s^2
    q_gyro_bias = 0.00; #deg/seg^2 | 0.001 suggested by charlie, but not deemed to be necessary
    q_accel_bias = 0.00; #m/sec^2/sec | 0.001 suggested by charlie and worked well on logs
    frame = "imu";

    #ms
    #bdi
    #timestep_dt = 0.003; # this is 1000/3=333.3R Hz - not 333Hz
    #ms - hyq
    #timestep_dt = 0.01; # MICROSTRAIN GX3-25
    timestep_dt = 0.004; # GAZEBO FREQUENCY
    #timestep_dt = 0.0125; # 80 Hz - old GX3 serial from logs
    # REMEMBER TO CHANGE THIS IF YOU CHANGE THE IMU FREQUENCY or downsample factor

    num_to_init = 100; # was 100 for microstrain, was 333 for MIT before
    # attempt to detect drastically incorrect initial gyro biases estimates:
    max_initial_gyro_bias = 0.00015; # deg/sec, biases above this will be set to zero

    # apply notch filtering on input: (to atlas imu accel signals)
    atlas_filter = false;
    atlas_filter_freq = 87.0; # correct for after March 2014 work
  }

  scan_matcher{
    channel = "SCAN_MATCHER";
    utime_offset = 0;
    downsample_factor = 1; # process 1 out of every this many
    roll_forward_on_receive = true;
    publish_head_on_message = false;
    mode = "position"; # yaw for drc, position 
    r_pxy = 0.01; # position in xy
    #r_pxy = 0.10; 

    r_pz =  0.03; # position in z
    #r_pz =  0.10; 

    r_vxy = 0.06; # velocity in xy
    #r_vxy = 0.10

    r_vz =  0.04; # velocity in z
    #r_vz =  0.10;

    r_yaw = 3.0;
  }

  vicon{
    channel = "TRANSF_GROUND_TRUTH";
    mode = "position"; # yaw for drc, position 
    apply_frame = false; # ???
    r_xyz = 0.01; # ???
    r_chi = 3.0; # ???
    r_pxy = 0.01; # position in xy
    r_pz =  0.01; # position in z
    r_vxy = 0.01; # velocity in xy
    r_vz =  0.01; # velocity in z
    r_yaw = 3.0;
    downsample_factor = 1;
    roll_forward_on_receive = true;
    publish_head_on_message = false;
    utime_offset = 0;
  }

  # correct the pose to this value: (to init using Pose BDI)
  pose_meas{
    no_corrections = 100; # apply this number of corrections before going silent
    channel = "POSE_DEBUG";
    utime_offset = 0; #units 1e-6 seconds
    downsample_factor = 1; # process 1 out of every this many
    roll_forward_on_receive = true;
    publish_head_on_message = false;

    r_xyz = .01; #m
    r_chi = 3.0; #degrees

    mode="position_orient"; # "position" "position_orient"
  }

   laser_gpf_out_of_process {
    utime_offset = 0;
    downsample_factor = 1; # i dont think this is used
    channel = "GPF_MEASUREMENT";
    roll_forward_on_receive = true;
    publish_head_on_message = false;
  }

  laser_gpf {
    utime_offset = 0;
    downsample_factor = 1;  # was 3 but rrg use 1
    channel = "VELODYNE_SUBSAMPLED";
    sensor_mode="pointcloud"; # laser or pointcloud
    roll_forward_on_receive = true;
    publish_head_on_message = false;
    gpf_vis = true;

    # N9:
    #map_name = "/home/mfallon/data/atlas/2014-01-21-vicon-walking/octomap/n9-2014-01-21.bt_blurred_0.5";
    map_name = "octomap.bt_blurred";
    #map_name = "from_lcm"; # this means it will be transmitted at launch
    blur_sigma = 0.3;# 0.3 # added by mfallon. was 0.5 previously in a stand alone process

    # 300 is bare min
    gpf_num_samples = 1000; # 1000 seemed to be noticably better than 500 (which I used alot)

    # according to abe:
    # pos_only - less accurate
    # pos_yaw  - sufficient/typical for fixie
    # pos_chi  - more accurate, use this initially for kmcl
    # mfallon: drc initially used pos_yaw
    gpf_substate = "pos_yaw";

    #laser projection settings
    projection_mode = "motion_interpolate"; # just added, this was motion_project by default, but now using motion_interpolate.
    beam_skip = 16;
    spatial_decimation_min = 0;
    spatial_decimation_max = .5;

    #-----------gpf probability settings-----------
    max_weight_proportion = 0.999; # max sum, for illconditioning. was hard coded as 0.99

    #log-likelihood of an unknown cell in the map
    unknown_loglike = -12.0; #original value used for johnson/parking garage 2012-5-13

    #gpf cov is scaled by sigma_scaling^2 via division of summed log probabilities
    # mfallon, jan 2014: mav used 8.16. I'm going to use something much smaller, mfallon
    # mfallon, mar 2014: i think this should actually be higher if not decimating
    sigma_scaling = 8.16; #8.16 # should be identical to "adams magic scaling factor used for johnson/parking garage 2012-5-13

    # enable the GPF at launch. bit flip with: STATE_EST_LASER_ENABLE/DISABLE. (mfallon april 2014)
    # this should be false for typical operartion but true for log testing
    enable_at_launch = true;
  }

  hyq_kse {
    channel = "HYQ_STATE";
    stance_threshold = 85; # threshold of GRF[z] to trigger the stance phase
    time_offset = 0.0; # time offset between vicon and other messages (useful for logs)
    verbose = true; # Prints warnings and messages 
    debug = true; # Sends signals and saves text files with signals
    robot = "HyQ"; # HyQ or HyQ2Max ?

    r_vx = 0.02; # initial covariance for x velocity component 
    r_vy = 0.02; # initial covariance for y velocity component
    r_vz = 0.02; # initial covariance fot z velocity component
    
    downsample_factor = 1;
    roll_forward_on_receive = true;
    utime_offset = 0; # do not confuse with time_offset
    publish_head_on_message = false;  
  }
}
